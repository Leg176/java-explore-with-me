{
	"info": {
		"_postman_id": "1b77645a-d148-4ac3-a206-6aa2d724da31",
		"name": "Comments Full Tests",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "46967030"
	},
	"item": [
		{
			"name": "PUBLIC API (/comments)",
			"item": [
				{
					"name": "Создание комментария неавторизованным пользователем",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const api = new API(pm);\r",
									"const rnd = new RandomUtils();\r",
									"\r",
									"(async () => {\r",
									"    try {\r",
									"        const author = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = await api.addEvent(author.id, rnd.getEvent(category.id));\r",
									"        event = await api.publishEvent(event.id);\r",
									"        \r",
									"        const commentData = {\r",
									"            name: \"Valid User Name\",\r",
									"            email: \"valid@email.com\",\r",
									"            description: \"This is a valid comment with more than 20 characters for anonymous user.\",\r",
									"            eventId: event.id\r",
									"        };\r",
									"        \r",
									"        pm.request.body.update({\r",
									"            mode: 'raw',\r",
									"            raw: JSON.stringify(commentData),\r",
									"            options: { raw: { language: 'json' } }\r",
									"        });\r",
									"        \r",
									"        pm.collectionVariables.set('pubEventId', event.id);\r",
									"        \r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных:\", err);\r",
									"        pm.collectionVariables.set('preRequestError', true);\r",
									"    }\r",
									"    \r",
									"    if (typeof done === 'function') {\r",
									"        done();\r",
									"    }\r",
									"})();"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Статус ответа 201\", function() {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"\r",
									"pm.test(\"Ответ в формате JSON\", function() {\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"pm.test(\"Тело ответа не пустое\", function() {\r",
									"    pm.expect(pm.response.text()).to.not.be.empty;\r",
									"});\r",
									"\r",
									"var responseBody;\r",
									"try {\r",
									"    responseBody = pm.response.json();\r",
									"} catch(e) {\r",
									"    pm.expect.fail(\"Ответ не является валидным JSON: \" + e.message);\r",
									"}\r",
									"\r",
									"if (responseBody) {\r",
									"    pm.test(\"Комментарий содержит обязательные поля\", function() {\r",
									"        pm.expect(responseBody).to.be.an('object');\r",
									"        pm.expect(responseBody).to.have.all.keys(['id', 'description', 'name', 'created']);\r",
									"    });\r",
									"    \r",
									"    pm.test(\"Длина описания не менее 20 символов\", function() {\r",
									"        pm.expect(responseBody.description).to.have.lengthOf.at.least(20);\r",
									"    });\r",
									"    \r",
									"    pm.test(\"Длина имени не менее 2 символов\", function() {\r",
									"        pm.expect(responseBody.name).to.have.lengthOf.at.least(2);\r",
									"    });\r",
									"    \r",
									"    pm.test(\"Формат даты корректный\", function() {\r",
									"        const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\r",
									"        pm.expect(responseBody.created).to.match(dateRegex);\r",
									"    });\r",
									"    \r",
									"    if (responseBody.id) {\r",
									"        pm.collectionVariables.set('publicCommentId', responseBody.id);\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"name\": \"Valid Name\",\r\n    \"email\": \"valid@email.com\",\r\n    \"description\": \"Valid description with at least 20 characters\",\r\n    \"eventId\": 1\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/comments",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"comments"
							]
						},
						"description": "POST /comments - создание комментария неавторизованным пользователем"
					},
					"response": []
				},
				{
					"name": "Получение опубликованного комментария по ID",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    try {\r",
									"        const author = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = await api.addEvent(author.id, rnd.getEvent(category.id));\r",
									"        event = await api.publishEvent(event.id);\r",
									"        \r",
									"        const commentData = {\r",
									"            name: \"Test User\",\r",
									"            email: \"test@example.com\",\r",
									"            description: \"Valid comment with more than twenty characters for testing.\",\r",
									"            eventId: event.id\r",
									"        };\r",
									"        \r",
									"        const createRequest = {\r",
									"            url: pm.variables.get('baseUrl') + '/comments',\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify(commentData)\r",
									"        };\r",
									"        \r",
									"        const createResponse = await new Promise((resolve, reject) => {\r",
									"            pm.sendRequest(createRequest, (err, res) => {\r",
									"                if (err) reject(err);\r",
									"                else resolve(res);\r",
									"            });\r",
									"        });\r",
									"        \r",
									"        const createdComment = createResponse.json();\r",
									"        const commentId = createdComment.id;\r",
									"        \r",
									"        const publishRequest = {\r",
									"            url: pm.variables.get('baseUrl') + '/admin/comments/' + commentId + '?state=PUBLISHED',\r",
									"            method: 'PATCH',\r",
									"            header: { 'Content-Type': 'application/json' }\r",
									"        };\r",
									"        \r",
									"        await new Promise((resolve, reject) => {\r",
									"            pm.sendRequest(publishRequest, (err, res) => {\r",
									"                if (err) {\r",
									"                    console.error(\"Ошибка публикации:\", err.message);\r",
									"                    // Если публикация не удалась (из-за @NotBlank), \r",
									"                    // все равно продолжаем тест - возможно комментарий уже доступен\r",
									"                }\r",
									"                resolve();\r",
									"            });\r",
									"        });\r",
									"        \r",
									"        pm.variables.set('pubCommentId', commentId);\r",
									"        console.log(\"Создан и опубликован комментарий ID:\", commentId);\r",
									"        \r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных:\", err);\r",
									"        pm.variables.set('pubCommentId', 1);\r",
									"    }\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"setTimeout(async () => {\r",
									"    try {\r",
									"        await main();\r",
									"    } catch (e) {\r",
									"        console.error(e);\r",
									"    } finally {\r",
									"        clearInterval(interval);\r",
									"    }\r",
									"}, 100);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Опубликованный комментарий должен возвращать статус 200\", function () {\r",
									"    pm.response.to.have.status(200);   \r",
									"    pm.response.to.be.withBody;\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"var responseBody = pm.response.json();\r",
									"pm.test(\"Комментарий должен содержать обязательные поля CommentDto\", function () {\r",
									"    pm.expect(responseBody).to.have.property('id');\r",
									"    pm.expect(responseBody.id).to.equal(parseInt(pm.variables.get('pubCommentId')));\r",
									"    pm.expect(responseBody).to.have.property('description');\r",
									"    pm.expect(responseBody.description.length).to.be.at.least(20);\r",
									"    pm.expect(responseBody).to.have.property('name');\r",
									"    pm.expect(responseBody.name.length).to.be.at.least(2);\r",
									"    pm.expect(responseBody).to.have.property('created');\r",
									"    pm.expect(responseBody).to.have.property('updated');\r",
									"});\r",
									"\r",
									"pm.test(\"Не должно быть полей, которых нет в CommentDto\", function () {\r",
									"    pm.expect(responseBody).to.not.have.property('eventId');\r",
									"    pm.expect(responseBody).to.not.have.property('user');\r",
									"    pm.expect(responseBody).to.not.have.property('email');\r",
									"    pm.expect(responseBody).to.not.have.property('status');\r",
									"    pm.expect(responseBody).to.not.have.property('authorId');\r",
									"});\r",
									"\r",
									"pm.test(\"Формат дат должен быть YYYY-MM-DD HH:mm:ss\", function () {\r",
									"    const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\r",
									"    pm.expect(responseBody.created).to.match(dateRegex);\r",
									"    pm.expect(responseBody.updated).to.match(dateRegex);\r",
									"});\r",
									"\r",
									"pm.test(\"Даты должны быть валидными\", function () {\r",
									"    const createdDate = new Date(responseBody.created.replace(' ', 'T') + 'Z');\r",
									"    const updatedDate = new Date(responseBody.updated.replace(' ', 'T') + 'Z');\r",
									"    \r",
									"    pm.expect(createdDate.toString()).to.not.equal('Invalid Date');\r",
									"    pm.expect(updatedDate.toString()).to.not.equal('Invalid Date');\r",
									"});\r",
									"\r",
									"pm.test(\"Дата обновления не должна быть раньше даты создания\", function () {\r",
									"    const createdDate = new Date(responseBody.created.replace(' ', 'T') + 'Z');\r",
									"    const updatedDate = new Date(responseBody.updated.replace(' ', 'T') + 'Z');\r",
									"    \r",
									"    pm.expect(updatedDate.getTime()).to.be.at.least(createdDate.getTime());\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/comments/:commentId",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"comments",
								":commentId"
							],
							"variable": [
								{
									"key": "commentId",
									"value": "{{pubCommentId}}"
								}
							]
						},
						"description": "GET /comments/{commentId} - получение опубликованного комментария"
					},
					"response": []
				},
				{
					"name": "Получение опубликованных комментариев события",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    try {\r",
									"        // 1. Создаем опубликованное событие\r",
									"        const author = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = await api.addEvent(author.id, rnd.getEvent(category.id));\r",
									"        event = await api.publishEvent(event.id);\r",
									"        \r",
									"        console.log(\"Создано опубликованное событие ID:\", event.id);\r",
									"        \r",
									"        // 2. Сохраняем ID события\r",
									"        pm.variables.set('eventIdForComments', event.id);\r",
									"        \r",
									"        // 3. Создаем и сразу публикуем комментарии\r",
									"        const createdCommentIds = [];\r",
									"        \r",
									"        // Комментарий 1\r",
									"        const commentData1 = {\r",
									"            name: \"User One\",\r",
									"            email: \"user1@example.com\",\r",
									"            description: \"First comment with more than twenty characters for the event.\",\r",
									"            eventId: event.id\r",
									"        };\r",
									"        \r",
									"        const createResponse1 = await new Promise((resolve, reject) => {\r",
									"            pm.sendRequest({\r",
									"                url: pm.variables.get('baseUrl') + '/comments',\r",
									"                method: 'POST',\r",
									"                header: { 'Content-Type': 'application/json' },\r",
									"                body: JSON.stringify(commentData1)\r",
									"            }, (err, res) => err ? reject(err) : resolve(res));\r",
									"        });\r",
									"        \r",
									"        const comment1 = createResponse1.json();\r",
									"        createdCommentIds.push(comment1.id);\r",
									"        console.log(\"Создан комментарий 1 ID:\", comment1.id);\r",
									"        \r",
									"        // Публикуем комментарий 1\r",
									"        await new Promise((resolve, reject) => {\r",
									"            pm.sendRequest({\r",
									"                url: pm.variables.get('baseUrl') + '/admin/comments/' + comment1.id + '?state=PUBLISHED',\r",
									"                method: 'PATCH',\r",
									"                header: { 'Content-Type': 'application/json' }\r",
									"            }, (err, res) => {\r",
									"                if (err) {\r",
									"                    console.error(\"Ошибка публикации комментария 1:\", err);\r",
									"                    reject(err);\r",
									"                } else {\r",
									"                    console.log(\"Комментарий 1 опубликован, статус:\", res.status);\r",
									"                    resolve(res);\r",
									"                }\r",
									"            });\r",
									"        });\r",
									"        \r",
									"        // Комментарий 2\r",
									"        const commentData2 = {\r",
									"            name: \"User Two\",\r",
									"            email: \"user2@example.com\",\r",
									"            description: \"Second valid comment with more than twenty characters.\",\r",
									"            eventId: event.id\r",
									"        };\r",
									"        \r",
									"        const createResponse2 = await new Promise((resolve, reject) => {\r",
									"            pm.sendRequest({\r",
									"                url: pm.variables.get('baseUrl') + '/comments',\r",
									"                method: 'POST',\r",
									"                header: { 'Content-Type': 'application/json' },\r",
									"                body: JSON.stringify(commentData2)\r",
									"            }, (err, res) => err ? reject(err) : resolve(res));\r",
									"        });\r",
									"        \r",
									"        const comment2 = createResponse2.json();\r",
									"        createdCommentIds.push(comment2.id);\r",
									"        console.log(\"Создан комментарий 2 ID:\", comment2.id);\r",
									"        \r",
									"        // Публикуем комментарий 2\r",
									"        await new Promise((resolve, reject) => {\r",
									"            pm.sendRequest({\r",
									"                url: pm.variables.get('baseUrl') + '/admin/comments/' + comment2.id + '?state=PUBLISHED',\r",
									"                method: 'PATCH',\r",
									"                header: { 'Content-Type': 'application/json' }\r",
									"            }, (err, res) => {\r",
									"                if (err) {\r",
									"                    console.error(\"Ошибка публикации комментария 2:\", err);\r",
									"                    reject(err);\r",
									"                } else {\r",
									"                    console.log(\"Комментарий 2 опубликован, статус:\", res.status);\r",
									"                    resolve(res);\r",
									"                }\r",
									"            });\r",
									"        });\r",
									"        \r",
									"        // Комментарий 3\r",
									"        const commentData3 = {\r",
									"            name: \"User Three\",\r",
									"            email: \"user3@example.com\",\r",
									"            description: \"Third test comment with more than required length.\",\r",
									"            eventId: event.id\r",
									"        };\r",
									"        \r",
									"        const createResponse3 = await new Promise((resolve, reject) => {\r",
									"            pm.sendRequest({\r",
									"                url: pm.variables.get('baseUrl') + '/comments',\r",
									"                method: 'POST',\r",
									"                header: { 'Content-Type': 'application/json' },\r",
									"                body: JSON.stringify(commentData3)\r",
									"            }, (err, res) => err ? reject(err) : resolve(res));\r",
									"        });\r",
									"        \r",
									"        const comment3 = createResponse3.json();\r",
									"        createdCommentIds.push(comment3.id);\r",
									"        console.log(\"Создан комментарий 3 ID:\", comment3.id);\r",
									"        \r",
									"        // Публикуем комментарий 3\r",
									"        await new Promise((resolve, reject) => {\r",
									"            pm.sendRequest({\r",
									"                url: pm.variables.get('baseUrl') + '/admin/comments/' + comment3.id + '?state=PUBLISHED',\r",
									"                method: 'PATCH',\r",
									"                header: { 'Content-Type': 'application/json' }\r",
									"            }, (err, res) => {\r",
									"                if (err) {\r",
									"                    console.error(\"Ошибка публикации комментария 3:\", err);\r",
									"                    reject(err);\r",
									"                } else {\r",
									"                    console.log(\"Комментарий 3 опубликован, статус:\", res.status);\r",
									"                    resolve(res);\r",
									"                }\r",
									"            });\r",
									"        });\r",
									"        \r",
									"        console.log(\"Всего создано и опубликовано комментариев:\", createdCommentIds.length);\r",
									"        console.log(\"ID комментариев:\", createdCommentIds);\r",
									"        \r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных:\", err);\r",
									"        pm.variables.set('eventIdForComments', 1);\r",
									"    }\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"setTimeout(async () => {\r",
									"    try {\r",
									"        await main();\r",
									"    } catch (e) {\r",
									"        console.error(e);\r",
									"    } finally {\r",
									"        clearInterval(interval);\r",
									"    }\r",
									"}, 100);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"let response;\r",
									"try {\r",
									"    response = pm.response.json();\r",
									"} catch (e) {\r",
									"    pm.expect.fail(\"Ответ не является JSON: \" + pm.response.text());\r",
									"}\r",
									"\r",
									"pm.test(\"Ответ не должен быть пустым\", function () {\r",
									"    pm.expect(response, \"Ответ пуст\").to.not.be.null;\r",
									"    pm.expect(response, \"Ответ пуст\").to.not.be.undefined;\r",
									"});\r",
									"\r",
									"pm.test(\"Ответ должен быть массивом\", function () {\r",
									"    pm.expect(Array.isArray(response), \"Ответ не является массивом\").to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Должны быть комментарии (массив не пустой)\", function () {\r",
									"    pm.expect(response.length, \"Массив комментариев пуст\").to.be.greaterThan(0);\r",
									"});\r",
									"\r",
									"pm.test(\"Количество комментариев не должно превышать размер страницы\", function () {\r",
									"    // Извлекаем параметр size из URL запроса\r",
									"    const urlString = pm.request.url.toString();\r",
									"    const urlObj = new URL(urlString);\r",
									"    const sizeParam = urlObj.searchParams.get('size');\r",
									"\r",
									"    // Если size не указан, считаем его равным 10 (стандартное значение)\r",
									"    let size = 10;\r",
									"    if (sizeParam) {\r",
									"        size = parseInt(sizeParam, 10);\r",
									"        // Проверка на валидность числа\r",
									"        if (isNaN(size) || size < 0) {\r",
									"            pm.expect.fail(`Параметр size='${sizeParam}' не является корректным числом`);\r",
									"        }\r",
									"    }\r",
									"\r",
									"    console.log(`Запрошенный размер страницы: ${size}, получено: ${response.length}`);\r",
									"\r",
									"    pm.expect(\r",
									"        response.length,\r",
									"        `Количество комментариев (${response.length}) превышает размер страницы (${size})`\r",
									"    ).to.be.at.most(size);\r",
									"});\r",
									"\r",
									"pm.test(\"Каждый комментарий должен иметь правильную структуру CommentDto\", function () {\r",
									"    response.forEach((comment, index) => {\r",
									"        pm.expect(comment, `Комментарий [${index}] не имеет поля 'id'`).to.have.property('id');\r",
									"        pm.expect(comment.id, `Комментарий [${index}].id не является числом`).to.be.a('number');\r",
									"\r",
									"        pm.expect(comment, `Комментарий [${index}] не имеет поля 'description'`).to.have.property('description');\r",
									"        if (comment.description) {\r",
									"            pm.expect(\r",
									"                comment.description.length,\r",
									"                `Комментарий [${index}].description короче 20 символов`\r",
									"            ).to.be.at.least(20);\r",
									"        }\r",
									"\r",
									"        pm.expect(comment, `Комментарий [${index}] не имеет поля 'name'`).to.have.property('name');\r",
									"        if (comment.name) {\r",
									"            pm.expect(\r",
									"                comment.name.length,\r",
									"                `Комментарий [${index}].name короче 2 символов`\r",
									"            ).to.be.at.least(2);\r",
									"        }\r",
									"\r",
									"        pm.expect(comment, `Комментарий [${index}] не имеет поля 'created'`).to.have.property('created');\r",
									"        pm.expect(comment, `Комментарий [${index}] не имеет поля 'updated'`).to.have.property('updated');\r",
									"\r",
									"        // Ослабляем требование: updated может отличаться от created\r",
									"        // pm.expect(comment.updated, `Комментарий [${index}].updated ≠ created`).to.equal(comment.created);\r",
									"\r",
									"        // Проверяем отсутствие лишних полей (опционально)\r",
									"        const forbiddenFields = ['eventId', 'user', 'email', 'status', 'authorId'];\r",
									"        forbiddenFields.forEach(field => {\r",
									"            pm.expect(comment, `Комментарий [${index}] содержит запрещённое поле '${field}'`).to.not.have.property(field);\r",
									"        });\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Формат дат должен быть YYYY-MM-DD HH:mm:ss\", function () {\r",
									"    const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\r",
									"    response.forEach((comment, index) => {\r",
									"        pm.expect(\r",
									"            comment.created,\r",
									"            `Комментарий [${index}].created не соответствует формату YYYY-MM-DD HH:mm:ss`\r",
									"        ).to.match(dateRegex);\r",
									"\r",
									"        pm.expect(\r",
									"            comment.updated,\r",
									"            `Комментарий [${index}].updated не соответствует формату YYYY-MM-DD HH:mm:ss`\r",
									"        ).to.match(dateRegex);\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Даты должны быть валидными\", function () {\r",
									"    response.forEach((comment, index) => {\r",
									"        const createdDate = new Date(comment.created.replace(' ', 'T') + 'Z');\r",
									"        const updatedDate = new Date(comment.updated.replace(' ', 'T') + 'Z');\r",
									"\r",
									"        pm.expect(\r",
									"            createdDate.toString(),\r",
									"            `Комментарий [${index}].created — невалидная дата`\r",
									"        ).to.not.equal('Invalid Date');\r",
									"\r",
									"        pm.expect(\r",
									"            updatedDate.toString(),\r",
									"            `Комментарий [${index}].updated — невалидная дата`\r",
									"        ).to.not.equal('Invalid Date');\r",
									"\r",
									"        // Если требуется строгая проверка равенства\r",
									"        // pm.expect(createdDate.getTime(), `Комментарий [${index}].created ≠ updated`).to.equal(updatedDate.getTime());\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Комментарии должны быть отсортированы по created (ASCENDING — старые первыми)\", function () {\r",
									"    if (response.length > 1) {\r",
									"        for (let i = 0; i < response.length - 1; i++) {\r",
									"            const current = new Date(response[i].created.replace(' ', 'T') + 'Z');\r",
									"            const next = new Date(response[i + 1].created.replace(' ', 'T') + 'Z');\r",
									"\r",
									"            pm.expect(\r",
									"                current.getTime(),\r",
									"                `Комментарии не отсортированы: запись ${i} позже записи ${i+1}`\r",
									"            ).to.be.at.most(next.getTime());\r",
									"        }\r",
									"    }\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/comments/event/:eventId?from=0&size=10",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"comments",
								"event",
								":eventId"
							],
							"query": [
								{
									"key": "from",
									"value": "0"
								},
								{
									"key": "size",
									"value": "10"
								}
							],
							"variable": [
								{
									"key": "eventId",
									"value": "{{eventIdForComments}}"
								}
							]
						},
						"description": "GET /comments/event/{eventId} - получение комментариев события"
					},
					"response": []
				}
			]
		},
		{
			"name": "PRIVATE API (/users/{userId}/comments)",
			"item": [
				{
					"name": "Создание комментария авторизованным пользователем",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        pm.collectionVariables.set(\"uid\", user.id);\r",
									"\r",
									"        const author = await api.addUser(rnd.getUser());\r",
									"\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = await api.addEvent(author.id, rnd.getEvent(category.id));\r",
									"        event = await api.publishEvent(event.id);\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"\r",
									"        const requestToJoin = await api.publishParticipationRequest(event.id, user.id);\r",
									"        const confirmedRequest = await api.acceptParticipationRequest(event.id, author.id, requestToJoin.id);\r",
									"        \r",
									"        const commentData = {\r",
									"            description: \"Valid comment text with more than twenty characters for authorized user.\",\r",
									"            eventId: event.id  // eventId в теле запроса!\r",
									"        };\r",
									"        \r",
									"        pm.request.body.update({\r",
									"            mode: 'raw',\r",
									"            raw: JSON.stringify(commentData),\r",
									"            options: { raw: { language: 'json' } }\r",
									"        });\r",
									"        \r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"setTimeout(async () => {\r",
									"    try {\r",
									"        await main();\r",
									"    } catch (e) {\r",
									"        console.error(e);\r",
									"    } finally {\r",
									"        clearInterval(interval);\r",
									"    }\r",
									"}, 100);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 201 и данные в формате json\", function() {\r",
									"    pm.response.to.have.status(201);\r",
									"    pm.response.to.be.withBody;\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"var responseBody = pm.response.json();\r",
									"\r",
									"pm.test(\"Комментарий должен содержать поля CommentDto\", function () {\r",
									"    pm.expect(responseBody).to.have.property('id');\r",
									"    pm.expect(responseBody).to.have.property('description');\r",
									"    pm.expect(responseBody.description.length).to.be.at.least(20);\r",
									"    pm.expect(responseBody).to.have.property('created');\r",
									"});\r",
									"\r",
									"pm.test(\"Для авторизованного пользователя должно быть поле user\", function () {\r",
									"    pm.expect(responseBody).to.have.property('user');\r",
									"    pm.expect(responseBody.user).to.not.be.null;\r",
									"    pm.expect(responseBody.user).to.have.property('id');\r",
									"    pm.expect(responseBody.user).to.have.property('name');\r",
									"});\r",
									"\r",
									"pm.test(\"ID пользователя в user должен соответствовать текущему пользователю\", function () {\r",
									"    const userId = pm.collectionVariables.get('uid');\r",
									"    pm.expect(responseBody.user.id.toString()).to.equal(userId.toString());\r",
									"});\r",
									"\r",
									"pm.test(\"Для нового комментария updated должно отсутствовать (null)\", function () {\r",
									"    pm.expect(responseBody).to.not.have.property('updated');\r",
									"});\r",
									"\r",
									"pm.test(\"Не должно быть полей, которых нет в CommentDto\", function () {\r",
									"    pm.expect(responseBody).to.not.have.property('eventId');\r",
									"    pm.expect(responseBody).to.not.have.property('authorId');\r",
									"    pm.expect(responseBody).to.not.have.property('status');\r",
									"    pm.expect(responseBody).to.not.have.property('text');\r",
									"});\r",
									"\r",
									"pm.test(\"Формат даты создания должен быть YYYY-MM-DD HH:mm:ss\", function () {\r",
									"    const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\r",
									"    pm.expect(responseBody.created).to.match(dateRegex);\r",
									"    \r",
									"    const createdDate = new Date(responseBody.created.replace(' ', 'T') + 'Z');\r",
									"    pm.expect(createdDate.toString()).to.not.equal('Invalid Date');\r",
									"});\r",
									"\r",
									"if (responseBody && responseBody.id) {\r",
									"    pm.collectionVariables.set('commentId', responseBody.id);\r",
									"    console.log(\"Создан комментарий для авторизованного пользователя ID:\", responseBody.id);\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"description\": \"Valid comment text...\",\r\n    \"eventId\": \"{{eid}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/comments",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"comments"
							]
						},
						"description": "POST /users/{userId}/comments?eventId={eventId} - создание комментария авторизованным пользователем"
					},
					"response": []
				},
				{
					"name": "Обновление комментария пользователем",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    try {\r",
									"        // 1. Получаем baseUrl - используем fallback\r",
									"        const baseUrl = pm.collectionVariables.get(\"baseUrl\") || \"http://localhost:8080\";\r",
									"        \r",
									"        // 2. Создаем пользователя\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const userId = user.id;\r",
									"        \r",
									"        // 3. Создаем автора события\r",
									"        const author = await api.addUser(rnd.getUser());\r",
									"        \r",
									"        // 4. Создаем категорию и событие\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = await api.addEvent(author.id, rnd.getEvent(category.id));\r",
									"        event = await api.publishEvent(event.id);\r",
									"        \r",
									"        // 5. Создаем комментарий\r",
									"        const commentData = {\r",
									"            description: \"Original comment text with more than twenty characters for update test.\",\r",
									"            eventId: event.id\r",
									"        };\r",
									"        \r",
									"        const createRes = await pm.sendRequest({\r",
									"            url: `${baseUrl}/users/${userId}/comments`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: JSON.stringify(commentData)\r",
									"        });\r",
									"        \r",
									"        // Используем statusCode для совместимости\r",
									"        const statusCode = createRes.statusCode || createRes.code;\r",
									"        if (statusCode !== 201) {\r",
									"            const errorText = createRes.text ? createRes.text() : (createRes.body || \"Нет тела ответа\");\r",
									"            throw new Error(`Не удалось создать комментарий: ${statusCode} - ${errorText}`);\r",
									"        }\r",
									"        \r",
									"        const comment = createRes.json();\r",
									"        const commentId = comment.id;\r",
									"        \r",
									"        // 6. Сохраняем переменные\r",
									"        pm.collectionVariables.set(\"commentId\", commentId);\r",
									"        pm.collectionVariables.set(\"uid\", userId);\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"        \r",
									"        // 7. Устанавливаем URL и тело запроса\r",
									"        pm.request.url = `${baseUrl}/users/${userId}/comments/${commentId}`;\r",
									"        \r",
									"        const updateData = {\r",
									"            description: \"Updated comment text with more than twenty characters after edit.\"\r",
									"        };\r",
									"        \r",
									"        pm.request.body.update({\r",
									"            mode: 'raw',\r",
									"            raw: JSON.stringify(updateData),\r",
									"            options: { raw: { language: 'json' } }\r",
									"        });\r",
									"        \r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка подготовки:\", err.message);\r",
									"        throw err;\r",
									"    }\r",
									"};\r",
									"\r",
									"// УПРОЩЕННЫЙ ЗАПУСК - убираем сложные таймауты\r",
									"(async () => {\r",
									"    try {\r",
									"        await main();\r",
									"    } catch (e) {\r",
									"        pm.test(\"Подготовка\", function() {\r",
									"            pm.expect.fail(\"Не удалось подготовить данные: \" + e.message);\r",
									"        });\r",
									"    }\r",
									"})();"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Статус 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"var response;\r",
									"try {\r",
									"    response = pm.response.json();\r",
									"    console.log(\"✅ Ответ:\", JSON.stringify(response, null, 2));\r",
									"} catch (e) {\r",
									"    console.error(\"❌ Не JSON:\", pm.response.text());\r",
									"    pm.expect.fail(\"Не JSON ответ\");\r",
									"    return;\r",
									"}\r",
									"\r",
									"pm.test(\"Структура CommentDto\", function () {\r",
									"    pm.expect(response).to.have.property('id');\r",
									"    pm.expect(response).to.have.property('description');\r",
									"    pm.expect(response).to.have.property('created');\r",
									"    pm.expect(response).to.have.property('user');\r",
									"    pm.expect(response).to.have.property('updated');\r",
									"    pm.expect(response.user).to.have.property('id');\r",
									"    pm.expect(response.user).to.have.property('name');\r",
									"});\r",
									"\r",
									"pm.test(\"ID не изменился\", function () {\r",
									"    const commentId = pm.collectionVariables.get('commentId');\r",
									"    pm.expect(response.id.toString()).to.equal(commentId.toString());\r",
									"});\r",
									"\r",
									"pm.test(\"Описание обновлено\", function () {\r",
									"    const requestBody = JSON.parse(pm.request.body.raw || '{}');\r",
									"    pm.expect(response.description).to.equal(requestBody.description);\r",
									"    pm.expect(response.description.length).to.be.at.least(20);\r",
									"});\r",
									"\r",
									"pm.test(\"Поле updated установлено\", function () {\r",
									"    pm.expect(response.updated).to.be.a('string').and.not.be.empty;\r",
									"    \r",
									"    const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\r",
									"    pm.expect(response.updated).to.match(dateRegex);\r",
									"    \r",
									"    const createdDate = new Date(response.created.replace(' ', 'T') + 'Z');\r",
									"    const updatedDate = new Date(response.updated.replace(' ', 'T') + 'Z');\r",
									"    pm.expect(updatedDate.getTime()).to.be.at.least(createdDate.getTime());\r",
									"    \r",
									"    console.log(\"✅ updated:\", response.updated);\r",
									"});\r",
									"\r",
									"pm.test(\"Автор не изменился\", function () {\r",
									"    const userId = pm.collectionVariables.get('uid');\r",
									"    pm.expect(response.user.id.toString()).to.equal(userId.toString());\r",
									"});\r",
									"\r",
									"pm.test(\"Формат created корректен\", function () {\r",
									"    const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\r",
									"    pm.expect(response.created).to.match(dateRegex);\r",
									"    \r",
									"    const createdDate = new Date(response.created.replace(' ', 'T') + 'Z');\r",
									"    pm.expect(createdDate.toString()).to.not.equal('Invalid Date');\r",
									"});\r",
									"\r",
									"pm.test(\"Нет лишних полей\", function () {\r",
									"    const allowedFields = ['id', 'description', 'created', 'updated', 'user'];\r",
									"    const responseFields = Object.keys(response);\r",
									"    \r",
									"    responseFields.forEach(field => {\r",
									"        pm.expect(allowedFields).to.include(field);\r",
									"    });\r",
									"    \r",
									"    const disallowedFields = ['eventId', 'authorId', 'status', 'state', 'text'];\r",
									"    disallowedFields.forEach(field => {\r",
									"        pm.expect(response).to.not.have.property(field);\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "PATCH",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"description\": \"Updated comment text with more than twenty characters after edit.\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/comments/{{commentId}}",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"comments",
								"{{commentId}}"
							]
						},
						"description": "PATCH /users/{userId}/comments/{commentId} - обновление комментария"
					},
					"response": []
				},
				{
					"name": "Отмена комментария пользователем",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    // ====== КРИТИЧЕСКИ ВАЖНО: ОЧИСТКА ======\r",
									"    pm.collectionVariables.unset(\"commentId\");\r",
									"    pm.collectionVariables.unset(\"uid\");\r",
									"    pm.collectionVariables.unset(\"eid\");\r",
									"    \r",
									"    // Для отладки\r",
									"    console.log(\"Очищены переменные коллекции\");\r",
									"    \r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    try {\r",
									"        // 1. Создаём пользователя (автор комментария)\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const userId = user.id;\r",
									"        pm.collectionVariables.set(\"uid\", userId);\r",
									"        console.log(\"Установлен uid:\", userId);\r",
									"\r",
									"        // 2. Создаём автора события\r",
									"        const author = await api.addUser(rnd.getUser());\r",
									"        const authorId = author.id;\r",
									"\r",
									"        // 3. Создаём категорию\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"\r",
									"        // 4. Создаём событие\r",
									"        const eventData = rnd.getEvent(category.id);\r",
									"        eventData.requestModeration = true;\r",
									"        eventData.participantLimit = 10;\r",
									"\r",
									"        let event = await api.addEvent(authorId, eventData);\r",
									"        const eventId = event.id;\r",
									"        pm.collectionVariables.set(\"eid\", eventId);\r",
									"        console.log(\"Установлен eid:\", eventId);\r",
									"\r",
									"        // 5. Публикуем событие\r",
									"        event = await api.publishEvent(eventId);\r",
									"\r",
									"        // 6. Отправляем и подтверждаем заявку на участие\r",
									"        const requestToJoin = await api.publishParticipationRequest(eventId, userId);\r",
									"        \r",
									"        if (requestToJoin && requestToJoin.status !== \"CONFIRMED\") {\r",
									"            try {\r",
									"                await api.acceptParticipationRequest(eventId, authorId, requestToJoin.id);\r",
									"            } catch (confirmError) {\r",
									"                console.warn(\"Не удалось подтвердить заявку:\", confirmError.message);\r",
									"            }\r",
									"        }\r",
									"\r",
									"        // 7. Создаём комментарий\r",
									"        const commentData = {\r",
									"            description: \"Comment to be canceled with more than twenty characters for test.\",\r",
									"            eventId: eventId\r",
									"        };\r",
									"\r",
									"        const createResponse = await pm.sendRequest({\r",
									"            url: `${pm.collectionVariables.get(\"baseUrl\")}/users/${userId}/comments`,\r",
									"            method: 'POST',\r",
									"            header: {'Content-Type': 'application/json'},\r",
									"            body: JSON.stringify(commentData)\r",
									"        });\r",
									"\r",
									"        if (createResponse.code !== 201) {\r",
									"            throw new Error(`Ошибка создания: ${createResponse.code} - ${createResponse.text()}`);\r",
									"        }\r",
									"\r",
									"        const comment = createResponse.json();\r",
									"        if (!comment || !comment.id) {\r",
									"            throw new Error(\"Нет ID в ответе: \" + JSON.stringify(comment));\r",
									"        }\r",
									"        \r",
									"        const commentId = comment.id;\r",
									"        \r",
									"        // ====== ВАЖНО: Устанавливаем ПЕРЕЗАПИСЫВАЕМ переменную ======\r",
									"        pm.collectionVariables.set(\"commentId\", commentId);\r",
									"        console.log(\"Установлен commentId:\", commentId);\r",
									"        console.log(\"Проверка commentId в переменных:\", pm.collectionVariables.get(\"commentId\"));\r",
									"\r",
									"        // 8. Формируем URL для отмены\r",
									"        const baseUrl = pm.collectionVariables.get(\"baseUrl\");\r",
									"        const cancelUrl = `${baseUrl}/users/${userId}/comments/${commentId}/cancel`;\r",
									"        \r",
									"        console.log(\"URL отмены:\", cancelUrl);\r",
									"        \r",
									"        pm.request.url = cancelUrl;\r",
									"        pm.request.method = 'PATCH';\r",
									"        pm.request.body.update({\r",
									"            mode: 'raw',\r",
									"            raw: '{}',\r",
									"            options: { raw: { language: 'json' } }\r",
									"        });\r",
									"\r",
									"    } catch (err) {\r",
									"        console.error(\"Ошибка в main():\", err.message);\r",
									"        throw err;\r",
									"    }\r",
									"};\r",
									"\r",
									"// Запуск\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"setTimeout(async () => {\r",
									"    try {\r",
									"        await main();\r",
									"    } catch (e) {\r",
									"        pm.test(\"Подготовка данных\", function() {\r",
									"            pm.expect.fail(`Не удалось подготовить: ${e.message}`);\r",
									"        });\r",
									"    } finally {\r",
									"        clearInterval(interval);\r",
									"    }\r",
									"}, 100);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Статус 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"var response;\r",
									"try {\r",
									"    response = pm.response.json();\r",
									"} catch (e) {\r",
									"    console.error(\"❌ Не JSON:\", pm.response.text());\r",
									"    pm.expect.fail(\"Не JSON ответ\");\r",
									"    return;\r",
									"}\r",
									"\r",
									"pm.test(\"Комментарий отменен\", function () {\r",
									"    pm.expect(response.state).to.equal(\"CANCELED\");\r",
									"});\r",
									"\r",
									"pm.test(\"ID сохранился\", function () {\r",
									"    const commentId = pm.collectionVariables.get('commentId');\r",
									"    pm.expect(response.id.toString()).to.equal(commentId.toString());\r",
									"});\r",
									"\r",
									"pm.test(\"Автор не изменился\", function () {\r",
									"    const userId = pm.collectionVariables.get('uid');\r",
									"    pm.expect(response.user.id.toString()).to.equal(userId.toString());\r",
									"});\r",
									"\r",
									"if (response.created && typeof response.created === 'string') {\r",
									"    pm.test(\"Поле created валидно\", function () {\r",
									"        const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\r",
									"        pm.expect(response.created).to.match(dateRegex);\r",
									"    });\r",
									"}\r",
									"\r",
									"if (response.updated && typeof response.updated === 'string') {\r",
									"    pm.test(\"Поле updated валидно\", function () {\r",
									"        const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\r",
									"        pm.expect(response.updated).to.match(dateRegex);\r",
									"    });\r",
									"}\r",
									"\r",
									"if (response.created && response.updated && \r",
									"    typeof response.created === 'string' && typeof response.updated === 'string') {\r",
									"    \r",
									"    try {\r",
									"        const createdDate = new Date(response.created.replace(' ', 'T') + 'Z');\r",
									"        const updatedDate = new Date(response.updated.replace(' ', 'T') + 'Z');\r",
									"        \r",
									"        if (!isNaN(createdDate.getTime()) && !isNaN(updatedDate.getTime())) {\r",
									"            pm.test(\"updated не раньше created\", function () {\r",
									"                pm.expect(updatedDate.getTime()).to.be.at.least(createdDate.getTime());\r",
									"            });\r",
									"        }\r",
									"    } catch (dateError) {\r",
									"        console.warn(\"Не удалось сравнить даты:\", dateError.message);\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "PATCH",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/comments/{{commentId}}/cancel",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"comments",
								"{{commentId}}",
								"cancel"
							]
						},
						"description": "PATCH /users/{userId}/comments/{commentId}/cancel - отмена комментария"
					},
					"response": []
				},
				{
					"name": "Получение комментариев пользователя с фильтрацией",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    try {\r",
									"        const creator = await api.addUser(rnd.getUser());\r",
									"        const creatorId = creator.id;\r",
									"        pm.collectionVariables.set(\"uid\", creatorId);\r",
									"        \r",
									"        const participant = await api.addUser(rnd.getUser());\r",
									"        const participantId = participant.id;\r",
									"        \r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        \r",
									"        let event = await api.addEvent(creatorId, rnd.getEvent(category.id));\r",
									"        const eventId = event.id;\r",
									"        \r",
									"        event = await api.publishEvent(eventId);\r",
									"        \r",
									"        pm.collectionVariables.set(\"eid\", eventId);\r",
									"        \r",
									"        const commentData = {\r",
									"            description: \"Comment from participant to creator's event with more than twenty characters.\",\r",
									"            eventId: eventId\r",
									"        };\r",
									"        \r",
									"        const createResponse = await pm.sendRequest({\r",
									"            url: `${pm.collectionVariables.get(\"baseUrl\")}/users/${participantId}/comments`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: { mode: 'raw', raw: JSON.stringify(commentData) }\r",
									"        });\r",
									"        \r",
									"        if (createResponse.code === 201) {\r",
									"            const comment = createResponse.json();\r",
									"            console.log(\"\\n🎉 КОММЕНТАРИЙ СОЗДАН УЧАСТНИКОМ!\");\r",
									"            console.log(\"   ID комментария:\", comment.id);\r",
									"            console.log(\"   Автор (должен быть участник):\", comment.user?.id);\r",
									"            console.log(\"   Состояние:\", comment.state);\r",
									"            \r",
									"            pm.collectionVariables.set(\"commentId\", comment.id);\r",
									"            \r",
									"            const commentCheck = await pm.sendRequest({\r",
									"                url: `${pm.collectionVariables.get(\"baseUrl\")}/comments/${comment.id}`,\r",
									"                method: 'GET'\r",
									"            });\r",
									"            \r",
									"        } else {\r",
									"            const error = createResponse.json();\r",
									"            if (error?.message) {\r",
									"                console.error(\"Причина:\", error.message);\r",
									"            }\r",
									"            return;\r",
									"        }\r",
									"        const currentUrl = pm.request.url.toString();\r",
									"        const newUrl = currentUrl\r",
									"            .replace('{{uid}}', creatorId.toString())\r",
									"            .replace('{{eid}}', eventId.toString());\r",
									"        \r",
									"        pm.request.url = newUrl;\r",
									"    } catch(err) {\r",
									"        console.error(\"❌ Ошибка:\", err.message);\r",
									"    }\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"setTimeout(async () => {\r",
									"    try {\r",
									"        await main();\r",
									"    } catch (e) {\r",
									"        console.error(e);\r",
									"    } finally {\r",
									"        clearInterval(interval);\r",
									"    }\r",
									"}, 100);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Статус 200\", function () {\r",
									"    pm.response.to.have.status(200);   \r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"var responseBody = pm.response.json();\r",
									"\r",
									"pm.test(\"Ответ должен быть массивом\", function () {\r",
									"    pm.expect(Array.isArray(responseBody)).to.be.true;\r",
									"});\r",
									"\r",
									"if (responseBody.length > 0) {\r",
									"    responseBody.forEach((comment, i) => {\r",
									"        console.log(`\\n${i + 1}. ID: ${comment.id}`);\r",
									"        console.log(`   Автор: ${comment.user?.id} (${comment.user?.name})`);\r",
									"        console.log(`   Состояние: ${comment.state}`);\r",
									"        console.log(`   Описание: ${comment.description?.substring(0, 50)}...`);\r",
									"    });\r",
									"    \r",
									"    pm.test(\"Комментарии имеют правильную структуру\", function () {\r",
									"        responseBody.forEach(comment => {\r",
									"            pm.expect(comment).to.have.all.keys(['id', 'description', 'created', 'state', 'user']);\r",
									"            pm.expect(comment.user).to.have.keys(['id', 'name']);\r",
									"            pm.expect(comment.description.length).to.be.at.least(20);\r",
									"        });\r",
									"    });\r",
									"    \r",
									"    const creatorId = pm.collectionVariables.get('uid');\r",
									"    responseBody.forEach((comment, i) => {\r",
									"        console.log(`Комментарий ${i + 1}: автор ${comment.user.id} !== создатель ${creatorId}?`, \r",
									"                   comment.user.id.toString() !== creatorId.toString());\r",
									"    });\r",
									"    \r",
									"} else {\r",
									"    console.log(\"⚠️ Массив все еще пуст!\");\r",
									"    \r",
									"    pm.test(\"Пустой массив - endpoint работает\", function () {\r",
									"        pm.expect(responseBody).to.be.an('array').that.is.empty;\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/comments?eventId={{eid}}&from=0&size=10",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"comments"
							],
							"query": [
								{
									"key": "eventId",
									"value": "{{eid}}"
								},
								{
									"key": "from",
									"value": "0"
								},
								{
									"key": "size",
									"value": "10"
								}
							]
						},
						"description": "GET /users/{userId}/comments - получение комментариев пользователя"
					},
					"response": []
				}
			]
		},
		{
			"name": "ADMIN API (/admin/comments)",
			"item": [
				{
					"name": "Получение списка комментариев с фильтрацией",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    try {\r",
									"        const author = await api.addUser(rnd.getUser());\r",
									"        const authorId = author.id;\r",
									"        \r",
									"        const user1 = await api.addUser(rnd.getUser());\r",
									"        const user2 = await api.addUser(rnd.getUser());\r",
									"        \r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = await api.addEvent(authorId, rnd.getEvent(category.id));\r",
									"        const eventId = event.id;\r",
									"        \r",
									"        event = await api.publishEvent(eventId);\r",
									"        pm.collectionVariables.set(\"eid\", eventId);\r",
									"        \r",
									"        const comment1Data = {\r",
									"            description: \"First admin test comment with more than twenty characters from user one.\",\r",
									"            eventId: eventId\r",
									"        };\r",
									"        \r",
									"        const create1Res = await pm.sendRequest({\r",
									"            url: `${pm.collectionVariables.get(\"baseUrl\")}/users/${user1.id}/comments`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: { mode: 'raw', raw: JSON.stringify(comment1Data) }\r",
									"        });\r",
									"        \r",
									"        if (create1Res.code === 201) {\r",
									"            const comment1 = create1Res.json();\r",
									"        }\r",
									"        \r",
									"        await new Promise(resolve => setTimeout(resolve, 100));\r",
									"        \r",
									"        const comment2Data = {\r",
									"            description: \"Second admin test comment with more than twenty characters from user two.\",\r",
									"            eventId: eventId\r",
									"        };\r",
									"        \r",
									"        const create2Res = await pm.sendRequest({\r",
									"            url: `${pm.collectionVariables.get(\"baseUrl\")}/users/${user2.id}/comments`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: { mode: 'raw', raw: JSON.stringify(comment2Data) }\r",
									"        });\r",
									"        \r",
									"        if (create2Res.code === 201) {\r",
									"            const comment2 = create2Res.json();\r",
									"            pm.collectionVariables.set(\"commentId\", comment2.id);\r",
									"        }\r",
									"        \r",
									"        const currentUrl = pm.request.url.toString();\r",
									"        const newUrl = currentUrl.replace('{{eid}}', eventId.toString());\r",
									"        pm.request.url = newUrl;\r",
									"        \r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка подготовки:\", err.message);\r",
									"    }\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"setTimeout(async () => {\r",
									"    try {\r",
									"        await main();\r",
									"    } catch (e) {\r",
									"        console.error(e);\r",
									"    } finally {\r",
									"        clearInterval(interval);\r",
									"    }\r",
									"}, 100);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Статус 200\", function () {\r",
									"    pm.response.to.have.status(200);   \r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"var responseBody;\r",
									"try {\r",
									"    responseBody = pm.response.json();\r",
									"    console.log(\"✅ Ответ распарсен\");\r",
									"} catch (e) {\r",
									"    console.error(\"❌ Ошибка парсинга:\", e);\r",
									"    pm.expect.fail(\"Не JSON ответ\");\r",
									"    return;\r",
									"}\r",
									"\r",
									"pm.test(\"Ответ должен быть массивом\", function () {\r",
									"    pm.expect(Array.isArray(responseBody)).to.be.true;\r",
									"});\r",
									"\r",
									"\r",
									"if (responseBody.length > 0) {\r",
									"    pm.test(\"Все комментарии имеют правильную структуру FullCommentDto\", function () {\r",
									"        responseBody.forEach(comment => {\r",
									"            pm.expect(comment).to.have.property('id');\r",
									"            pm.expect(comment).to.have.property('description');\r",
									"            pm.expect(comment).to.have.property('created');\r",
									"            pm.expect(comment).to.have.property('state');\r",
									"            pm.expect(comment).to.have.property('user');\r",
									"        \r",
									"            pm.expect(comment.user).to.have.property('id');\r",
									"            pm.expect(comment.user).to.have.property('name');\r",
									"            \r",
									"            pm.expect(comment.description.length).to.be.at.least(20);\r",
									"            \r",
									"            if (comment.updated !== undefined) {\r",
									"                pm.expect(comment.updated).to.be.a('string');\r",
									"            }\r",
									"            \r",
									"            if (comment.name !== undefined) {\r",
									"                pm.expect(comment.name).to.be.a('string');\r",
									"            }\r",
									"        });\r",
									"    });\r",
									"    \r",
									"    const authors = [...new Set(responseBody.map(c => c.user.id))];\r",
									"    \r",
									"    const url = new URL(pm.request.url.toString());\r",
									"    const size = parseInt(url.searchParams.get('size')) || 10;\r",
									"    \r",
									"    pm.test(\"Количество комментариев соответствует size\", function () {\r",
									"        pm.expect(responseBody.length).to.be.at.most(size);\r",
									"    });\r",
									"    \r",
									"} else {\r",
									"    pm.test(\"Пустой массив - валидный ответ\", function () {\r",
									"        pm.expect(responseBody).to.be.an('array').that.is.empty;\r",
									"    });\r",
									"}\r",
									"\r",
									"pm.test(\"Нет полей вне FullCommentDto\", function () {\r",
									"    const allowedFields = ['id', 'description', 'name', 'created', 'updated', 'state', 'user'];\r",
									"    \r",
									"    responseBody.forEach(comment => {\r",
									"        Object.keys(comment).forEach(field => {\r",
									"            pm.expect(allowedFields).to.include(field);\r",
									"        });\r",
									"        \r",
									"        const disallowedFields = ['text', 'status', 'authorId', 'eventId'];\r",
									"        disallowedFields.forEach(field => {\r",
									"            pm.expect(comment).to.not.have.property(field);\r",
									"        });\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/admin/comments?eventId={{eid}}&from=0&size=10",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"admin",
								"comments"
							],
							"query": [
								{
									"key": "eventId",
									"value": "{{eid}}"
								},
								{
									"key": "from",
									"value": "0"
								},
								{
									"key": "size",
									"value": "10"
								}
							]
						},
						"description": "GET /admin/comments - получение комментариев с фильтрацией"
					},
					"response": []
				},
				{
					"name": "Изменение статуса комментария",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const userId = user.id;\r",
									"        \r",
									"        const author = await api.addUser(rnd.getUser());\r",
									"        \r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = await api.addEvent(author.id, rnd.getEvent(category.id));\r",
									"        const eventId = event.id;\r",
									"        event = await api.publishEvent(eventId);\r",
									"        \r",
									"        const commentData = {\r",
									"            description: \"Comment for admin status update test with more than twenty characters.\",\r",
									"            eventId: eventId\r",
									"        };\r",
									"        \r",
									"        const createRes = await pm.sendRequest({\r",
									"            url: `${pm.collectionVariables.get(\"baseUrl\")}/users/${userId}/comments`,\r",
									"            method: 'POST',\r",
									"            header: { 'Content-Type': 'application/json' },\r",
									"            body: { mode: 'raw', raw: JSON.stringify(commentData) }\r",
									"        });\r",
									"        \r",
									"        if (createRes.code !== 201) {\r",
									"            throw new Error(\"Не удалось создать комментарий: \" + createRes.text());\r",
									"        }\r",
									"        \r",
									"        const comment = createRes.json();\r",
									"        const commentId = comment.id;\r",
									"        pm.collectionVariables.set(\"commentId\", commentId);\r",
									"\r",
									"        const targetState = \"CANCELED\";\r",
									"        console.log(`   ⚙️  Так как комментарий уже PUBLISHED, Admin может только отменить его`);\r",
									"        console.log(`   ⚙️  Admin изменит статус: PUBLISHED → CANCELED`);\r",
									"        \r",
									"        const baseUrl = pm.collectionVariables.get(\"baseUrl\");\r",
									"        const finalUrl = `${baseUrl}/admin/comments/${commentId}?state=${targetState}`;\r",
									"        \r",
									"        pm.request.url = finalUrl;\r",
									"        \r",
									"        pm.request.body.update({\r",
									"            mode: 'raw',\r",
									"            raw: '',\r",
									"            options: { raw: { language: 'text' } }\r",
									"        });\r",
									"        \r",
									"        pm.collectionVariables.set(\"expectedState\", targetState);\r",
									"        pm.collectionVariables.set(\"originalState\", \"PUBLISHED\");\r",
									"        \r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка подготовки:\", err.message);\r",
									"        throw err;\r",
									"    }\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"setTimeout(async () => {\r",
									"    try {\r",
									"        await main();\r",
									"    } catch (e) {\r",
									"        console.error(e);\r",
									"        pm.test(\"Подготовка\", function() {\r",
									"            pm.expect.fail(\"Не удалось подготовить данные: \" + e.message);\r",
									"        });\r",
									"    } finally {\r",
									"        clearInterval(interval);\r",
									"    }\r",
									"}, 100);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Проверка статуса ответа\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"var response;\r",
									"try {\r",
									"    response = pm.response.json();\r",
									"} catch (e) {\r",
									"    console.error(\"❌ Не JSON:\", pm.response.text());\r",
									"    pm.expect.fail(\"Ответ не в формате JSON\");\r",
									"    return;\r",
									"}\r",
									"\r",
									"pm.test(\"Ответ содержит FullCommentDto\", function () {\r",
									"    pm.expect(response).to.have.property('id');\r",
									"    pm.expect(response).to.have.property('description');\r",
									"    pm.expect(response).to.have.property('created');\r",
									"    pm.expect(response).to.have.property('state');\r",
									"    pm.expect(response).to.have.property('user');\r",
									"    pm.expect(response).to.have.property('updated');\r",
									"    \r",
									"    pm.expect(response.user).to.have.property('id');\r",
									"    pm.expect(response.user).to.have.property('name');\r",
									"});\r",
									"\r",
									"pm.test(\"ID комментария остался прежним\", function () {\r",
									"    const commentId = pm.collectionVariables.get('commentId');\r",
									"    pm.expect(response.id.toString()).to.equal(commentId.toString());\r",
									"});\r",
									"\r",
									"pm.test(\"Статус изменен на CANCELED\", function () {\r",
									"    const url = new URL(pm.request.url.toString());\r",
									"    const requestedState = url.searchParams.get('state');\r",
									"    \r",
									"    pm.expect(requestedState).to.equal(\"CANCELED\");\r",
									"    pm.expect(response.state).to.equal(\"CANCELED\");\r",
									"});\r",
									"\r",
									"pm.test(\"Поле updated установлено\", function () {\r",
									"    pm.expect(response.updated).to.be.a('string').and.not.be.empty;\r",
									"    \r",
									"    const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\r",
									"    pm.expect(response.updated).to.match(dateRegex);\r",
									"    \r",
									"    const createdDate = new Date(response.created.replace(' ', 'T') + 'Z');\r",
									"    const updatedDate = new Date(response.updated.replace(' ', 'T') + 'Z');\r",
									"    pm.expect(updatedDate.getTime()).to.be.at.least(createdDate.getTime());\r",
									"    \r",
									"    console.log(\"✅ Поле updated установлено:\", response.updated);\r",
									"});\r",
									"\r",
									"pm.test(\"Описание комментария сохранилось\", function () {\r",
									"    pm.expect(response.description).to.be.a('string');\r",
									"    pm.expect(response.description.length).to.be.at.least(20);\r",
									"});\r",
									"\r",
									"pm.test(\"Автор комментария не изменился\", function () {\r",
									"    pm.expect(response.user).to.be.an('object');\r",
									"    pm.expect(response.user.id).to.be.a('number').and.to.be.at.least(1);\r",
									"    pm.expect(response.user.name).to.be.a('string').and.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Состояние валидно и равно CANCELED\", function () {\r",
									"    const validStates = ['PUBLISHED', 'CANCELED'];\r",
									"    pm.expect(validStates).to.include(response.state);\r",
									"    pm.expect(response.state).to.equal(\"CANCELED\");\r",
									"});\r",
									"\r",
									"pm.test(\"Дата created в правильном формате\", function () {\r",
									"    const dateRegex = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/;\r",
									"    pm.expect(response.created).to.match(dateRegex);\r",
									"    \r",
									"    const createdDate = new Date(response.created.replace(' ', 'T') + 'Z');\r",
									"    pm.expect(createdDate.toString()).to.not.equal('Invalid Date');\r",
									"});\r",
									"\r",
									"pm.test(\"Администратор успешно отменил опубликованный комментарий\", function () {\r",
									"    const url = new URL(pm.request.url.toString());\r",
									"    const requestedState = url.searchParams.get('state');\r",
									"    \r",
									"    if (requestedState === \"CANCELED\" && response.state === \"CANCELED\") {\r",
									"        console.log(\"   ✓ Комментарий успешно отменен администратором\");\r",
									"    }\r",
									"});\r",
									"\r",
									"const urlParams = new URL(pm.request.url.toString()).searchParams;\r",
									"urlParams.forEach((value, key) => {\r",
									"    console.log(`  ${key}: ${value}`);\r",
									"});\r",
									"\r",
									"pm.test(\"Нет лишних полей вне FullCommentDto\", function () {\r",
									"    const allowedFields = ['id', 'description', 'created', 'updated', 'state', 'user'];\r",
									"    const responseFields = Object.keys(response);\r",
									"    \r",
									"    responseFields.forEach(field => {\r",
									"        pm.expect(allowedFields).to.include(field);\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Комментарий отменен администратором\", function () {\r",
									"    pm.expect(response.state).to.equal(\"CANCELED\");\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "PATCH",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"url": {
							"raw": "{{baseUrl}}/admin/comments/{{commentId}}?state={state}",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"admin",
								"comments",
								"{{commentId}}"
							],
							"query": [
								{
									"key": "state",
									"value": "{state}"
								}
							]
						},
						"description": "PATCH /admin/comments/{commentId}?state={state} - изменение статуса комментария"
					},
					"response": []
				},
				{
					"name": "Удаление комментария администратором",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const author = await api.addUser(rnd.getUser());\r",
									"        pm.collectionVariables.set(\"uid\", user.id);\r",
									"\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = await api.addEvent(author.id, rnd.getEvent(category.id));\r",
									"        event = await api.publishEvent(event.id);\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"\r",
									"        const requestToJoin = await api.publishParticipationRequest(event.id, user.id);\r",
									"        const confirmedRequest = await api.acceptParticipationRequest(event.id, author.id, requestToJoin.id);\r",
									"        const comment = await api.addComment(user.id, event.id, rnd.getComment());\r",
									"        pm.collectionVariables.set(\"commentId\", comment.id);\r",
									"\r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"\r",
									"setTimeout(async () => \r",
									"    {\r",
									"        try {\r",
									"            await main();\r",
									"        } catch (e) {\r",
									"            console.error(e);\r",
									"        } finally {\r",
									"            clearInterval(interval);\r",
									"        }\r",
									"    },  \r",
									"    100 \r",
									");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 204\", function () {\r",
									"    pm.response.to.have.status(204);\r",
									"    pm.response.to.have.body('');\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/admin/comments/:commentId",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"admin",
								"comments",
								":commentId"
							],
							"variable": [
								{
									"key": "commentId",
									"value": "{{commentId}}"
								}
							]
						},
						"description": "DELETE /admin/comments/{commentId} - удаление комментария"
					},
					"response": []
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"requests": {},
				"exec": [
					"// Ваши оригинальные API и RandomUtils",
					"API = class {",
					"    constructor(postman, verbose = false, baseUrl = \"http://localhost:8080\") {",
					"        this.baseUrl = baseUrl;",
					"        this.pm = postman;",
					"        this._verbose = verbose;",
					"    }",
					"",
					"    async addUser(user, verbose=null) {",
					"        return this.post(\"/admin/users\", user, \"Ошибка при добавлении нового пользователя: \", verbose);",
					"    }",
					"",
					"    async addCategory(category, verbose=null) {",
					"        return this.post(\"/admin/categories\", category, \"Ошибка при добавлении новой категории: \", verbose);",
					"    }",
					"",
					"    async addEvent(userId, event, verbose=null) {",
					"        return this.post(\"/users/\" + userId + \"/events\", event, \"Ошибка при добавлении нового события: \", verbose);",
					"    }",
					"",
					"    async addCompilation(compilation, verbose=null) {",
					"        return this.post(\"/admin/compilations\", compilation, \"Ошибка при добавлении новой подборки: \", verbose);",
					"    }",
					"",
					"    async publishParticipationRequest(eventId, userId, verbose=null) {",
					"        return this.post('/users/' + userId + '/requests?eventId=' + eventId, null, \"Ошибка при добавлении нового запроса на участие в событии\", verbose);",
					"    }",
					"",
					"    async publishEvent(eventId, verbose=null) {",
					"        return this.patch('/admin/events/' + eventId, {stateAction: \"PUBLISH_EVENT\"}, \"Ошибка при публикации события\", verbose);",
					"    }",
					"    ",
					"    async rejectEvent(eventId, verbose=null) {",
					"        return this.patch('/admin/events/' + eventId, {stateAction: \"REJECT_EVENT\"}, \"Ошибка при отмене события\", verbose);",
					"    }",
					"",
					"    async acceptParticipationRequest(eventId, userId, reqId, verbose=null) {",
					"        return this.patch('/users/' + userId + '/events/' + eventId + '/requests', {requestIds:[reqId], status: \"CONFIRMED\"}, \"Ошибка при принятии заявки на участие в событии\", verbose);",
					"    }",
					"",
					"    async findCategory(catId, verbose=null) {",
					"        return this.get('/categories/' + catId, null, \"Ошибка при поиске категории по id\", verbose);",
					"    }",
					"",
					"    async findCompilation(compId, verbose=null) {",
					"        return this.get('/compilations/' + compId, null, \"Ошибка при поиске подборки по id\", verbose);",
					"    }",
					"",
					"    async findEvent(eventId, verbose=null) {",
					"        return this.get('/events/' + eventId, null, \"Ошибка при поиске события по id\", verbose);",
					"    }",
					"",
					"    async findUser(userId, verbose=null) {",
					"        return this.get('/admin/users?ids=' + userId, null, \"Ошибка при поиске пользователя по id\", verbose);",
					"    }",
					"",
					"    async addComment(userId, eventId, comment, verbose = null) {",
					"        return this.post(`/users/${userId}/comments?eventId=${eventId}`, ",
					"            comment, ",
					"            \"Ошибка при добавлении комментария: \", ",
					"            verbose",
					"        );",
					"    }",
					"",
					"    async updateComment(userId, commentId, comment, verbose = null) {",
					"        return this.patch(`/users/${userId}/comments/${commentId}`, ",
					"            comment, ",
					"            \"Ошибка при обновлении комментария: \", ",
					"            verbose",
					"        );",
					"    }",
					"",
					"    async post(path, body, errorText = \"Ошибка при выполнении post-запроса: \", verbose=null) {",
					"        return this.sendRequest(\"POST\", path, body, errorText, verbose);",
					"    }",
					"",
					"    async patch(path, body = null, errorText = \"Ошибка при выполнении patch-запроса: \", verbose=null) {",
					"        return this.sendRequest(\"PATCH\", path, body, errorText, verbose);",
					"    }",
					"",
					"    async get(path, body = null, errorText = \"Ошибка при выполнении get-запроса: \", verbose=null) {",
					"        return this.sendRequest(\"GET\", path, body, errorText, verbose);",
					"    }",
					"    async sendRequest(method, path, body=null, errorText = \"Ошибка при выполнении запроса: \", verbose=null) {",
					"        return new Promise((resolve, reject) => {",
					"            verbose = verbose == null ? this._verbose : verbose;",
					"            const request = {",
					"                url: this.baseUrl + path,",
					"                method: method,",
					"                body: body == null ? \"\" : JSON.stringify(body),",
					"                header: { \"Content-Type\": \"application/json\" },",
					"            };",
					"            if(verbose) {",
					"                console.log(\"Отправляю запрос: \", request);",
					"            }",
					"",
					"            try {",
					"                this.pm.sendRequest(request, (error, response) => {",
					"                    if(error || (response.code >= 400 && response.code <= 599)) {",
					"                        let err = error ? error : JSON.stringify(response.json());",
					"                        console.error(\"При выполнении запроса к серверу возникла ошика.\\n\", err,",
					"                             \"\\nДля отладки проблемы повторите такой же запрос к вашей программе \" + ",
					"                             \"на локальном компьютере. Данные запроса:\\n\", JSON.stringify(request));",
					"",
					"                        reject(new Error(errorText + err));",
					"                    }",
					"                    if(verbose) {",
					"                        console.log(\"Результат обработки запроса: код состояния - \", response.code, \", тело: \", response.json());",
					"                    }",
					"                    if (response.stream.length === 0){",
					"                        reject(new Error('Отправлено пустое тело ответа'))",
					"                    }else{",
					"                        resolve(response.json());",
					"                    }",
					"                });",
					"                ",
					"            } catch(err) {",
					"                if(verbose) {",
					"                    console.error(errorText, err);",
					"                }",
					"                return Promise.reject(err);",
					"            }",
					"        });",
					"    }",
					"};",
					"",
					"RandomUtils = class {",
					"    constructor() {}",
					"",
					"    getUser() {",
					"        return {",
					"            name: pm.variables.replaceIn('{{$randomFullName}}'),",
					"            email: pm.variables.replaceIn('{{$randomEmail}}')",
					"        };",
					"    }",
					"",
					"    getComment() {",
					"        return {",
					"            text: pm.variables.replaceIn('{{$randomWord}}')",
					"        };",
					"    }",
					"",
					"    getCategory() {",
					"        return {",
					"            name: pm.variables.replaceIn('{{$randomWord}}') + Math.floor(Math.random() * 10000 * Math.random()).toString()",
					"        };",
					"    }",
					"",
					"    getEvent(categoryId) {",
					"        return {",
					"            annotation: pm.variables.replaceIn('{{$randomLoremParagraph}}'),",
					"            category: categoryId,",
					"            description: pm.variables.replaceIn('{{$randomLoremParagraphs}}'),",
					"            eventDate: this.getFutureDateTime(),",
					"            location: {",
					"                lat: parseFloat(pm.variables.replaceIn('{{$randomLatitude}}')),",
					"                lon: parseFloat(pm.variables.replaceIn('{{$randomLongitude}}')),",
					"            },",
					"            paid: pm.variables.replaceIn('{{$randomBoolean}}'),",
					"            participantLimit: pm.variables.replaceIn('{{$randomInt}}'),",
					"            requestModeration: pm.variables.replaceIn('{{$randomBoolean}}'),",
					"            title: pm.variables.replaceIn('{{$randomLoremSentence}}'),",
					"        }",
					"    }",
					"",
					"    getCompilation(...eventIds) {",
					"        return {",
					"            title: pm.variables.replaceIn('{{$randomLoremSentence}}').slice(0, 50),",
					"            pinned: pm.variables.replaceIn('{{$randomBoolean}}'),",
					"            events: eventIds",
					"        };",
					"    }",
					"",
					"",
					"    getFutureDateTime(hourShift = 5, minuteShift=0, yearShift=0) {",
					"        let moment = require('moment');",
					"",
					"        let m = moment();",
					"        m.add(hourShift, 'hour');",
					"        m.add(minuteShift, 'minute');",
					"        m.add(yearShift, 'year');",
					"",
					"        return m.format('YYYY-MM-DD HH:mm:ss');",
					"    }",
					"",
					"    getWord(length = 1) {",
					"        let result = '';",
					"        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';",
					"        const charactersLength = characters.length;",
					"        let counter = 0;",
					"        while (counter < length) {",
					"            result += characters.charAt(Math.floor(Math.random() * charactersLength));",
					"            counter += 1;",
					"        }",
					"        return result;",
					"    }",
					"}"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"requests": {},
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "baseUrl",
			"value": "http://localhost:8080"
		},
		{
			"key": "uid",
			"value": 1
		},
		{
			"key": "eid",
			"value": 1
		},
		{
			"key": "pubEventId",
			"value": ""
		},
		{
			"key": "publicCommentId",
			"value": ""
		},
		{
			"key": "pubCommentId",
			"value": ""
		},
		{
			"key": "state",
			"value": ""
		},
		{
			"key": "state",
			"value": ""
		},
		{
			"key": "userId",
			"value": ""
		},
		{
			"key": "commentId",
			"value": ""
		},
		{
			"key": "expectedState",
			"value": ""
		},
		{
			"key": "originalState",
			"value": ""
		}
	]
}